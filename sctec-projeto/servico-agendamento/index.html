<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sincroniza√ß√£o de Tempo - Algoritmo de Berkeley</title>
    
    
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .time-display {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .time-display .label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .time-display .time {
            font-size: 32px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .info-item {
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }

        .info-item .label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .info-item .value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .log-container {
            grid-column: 1 / -1;
        }

        .log {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-entry {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid transparent;
        }

        .log-entry.info {
            border-left-color: #3498db;
            background: #ebf5fb;
        }

        .log-entry.success {
            border-left-color: #27ae60;
            background: #eafaf1;
        }

        .log-entry.warning {
            border-left-color: #f39c12;
            background: #fef5e7;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
            background: #fadbd8;
        }

        .timestamp {
            color: #666;
            margin-right: 10px;
        }

        .status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }

        .status.connected {
            background: #27ae60;
            color: white;
        }

        .status.disconnected {
            background: #e74c3c;
            color: white;
        }

        .status.syncing {
            background: #f39c12;
            color: white;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üïê Sistema de Sincroniza√ß√£o de Tempo</h1>
            <p class="subtitle">Algoritmo de Berkeley - Computa√ß√£o Distribu√≠da</p>
        </header>

        <div class="main-content">
            <div class="card">
                <h2>‚è∞ Rel√≥gio Local</h2>
                <div class="time-display">
                    <div class="label">Hora Local</div>
                    <div class="time" id="localTime">--:--:--</div>
                </div>

                <div class="controls">
                    <button onclick="berkeleySync.connect()">Conectar</button>
                    <button onclick="berkeleySync.disconnect()">Desconectar</button>
                    <button onclick="berkeleySync.syncTime()">Sincronizar</button>
                    <button onclick="berkeleySync.addRandomDelay()">Adicionar Atraso</button>
                </div>

                <div class="info-grid">
                    <div class="info-item">
                        <div class="label">Status</div>
                        <div class="value" id="connectionStatus">
                            <span class="status disconnected">Desconectado</span>
                        </div>
                    </div>
                    <div class="info-item">
                        <div class="label">Diferen√ßa</div>
                        <div class="value" id="timeDiff">0 ms</div>
                    </div>
                    <div class="info-item">
                        <div class="label">√öltima Sinc.</div>
                        <div class="value" id="lastSync">Nunca</div>
                    </div>
                    <div class="info-item">
                        <div class="label">RTT M√©dio</div>
                        <div class="value" id="avgRTT">0 ms</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üñ•Ô∏è Servidor de Tempo</h2>
                <div class="time-display">
                    <div class="label">Hora do Servidor</div>
                    <div class="time" id="serverTime">--:--:--</div>
                </div>

                <div class="info-grid">
                    <div class="info-item">
                        <div class="label">Clientes Conectados</div>
                        <div class="value" id="clientCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="label">Sincroniza√ß√µes</div>
                        <div class="value" id="syncCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="label">Tempo M√©dio</div>
                        <div class="value" id="avgTime">--:--:--</div>
                    </div>
                    <div class="info-item">
                        <div class="label">Desvio Padr√£o</div>
                        <div class="value" id="stdDev">0 ms</div>
                    </div>
                </div>

                <div class="controls">
                    <button onclick="berkeleySync.simulateMultipleClients(3)">Simular 3 Clientes</button>
                    <button onclick="berkeleySync.clearLogs()">Limpar Logs</button>
                </div>

                <!-- Controles para interagir com a API (UI) -->
                <div style="margin-top:12px;">
                    <h3 style="margin-bottom:8px;color:#333;font-size:16px">Agendamentos (UI)</h3>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
                        <input id="telescopeInput" placeholder="Telescope ID (ex: hubble-acad)" style="padding:8px;border-radius:4px;border:1px solid #ddd" />
                        <input id="scientistInput" placeholder="Scientist ID (ex: 1)" style="padding:8px;border-radius:4px;border:1px solid #ddd" />
                        <input id="startInput" placeholder="Start UTC (YYYY-MM-DDTHH:MM:SSZ)" style="padding:8px;border-radius:4px;border:1px solid #ddd" />
                        <input id="endInput" placeholder="End UTC (YYYY-MM-DDTHH:MM:SSZ)" style="padding:8px;border-radius:4px;border:1px solid #ddd" />
                    </div>

                    <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap">
                        <button onclick="createBookingFromUI()">Criar Agendamento</button>
                        <button onclick="listBookingsFromUI()">Listar Agendamentos</button>
                        <input id="bookingIdInput" placeholder="Booking ID para cancelar" style="padding:8px;border-radius:4px;border:1px solid #ddd;min-width:180px" />
                        <button onclick="cancelBookingFromUI()">Cancelar Agendamento</button>
                    </div>
                </div>
            </div>

            <div class="card log-container">
                <h2>üìã Log de Sincroniza√ß√£o</h2>
                <div class="log" id="logContainer"></div>
            </div>
        </div>
    </div>

    <script>
        class BerkeleySynchronization {
            constructor() {
                this.localTimeOffset = 0; // Offset em milissegundos
                this.serverTimeOffset = 0;
                this.isConnected = false;
                this.clientId = this.generateClientId();
                this.clients = [];
                this.syncCount = 0;
                this.rttHistory = [];
                
                this.init();
            }

            generateClientId() {
                return 'client_' + Math.random().toString(36).substr(2, 9);
            }

            init() {
                this.updateClocks();
                setInterval(() => this.updateClocks(), 100);
                this.log('Sistema iniciado', 'info');
            }

            updateClocks() {
                const now = Date.now();
                
                // Atualiza rel√≥gio local
                const localTime = new Date(now + this.localTimeOffset);
                document.getElementById('localTime').textContent = this.formatTime(localTime);
                
                // Atualiza rel√≥gio do servidor
                const serverTime = new Date(now + this.serverTimeOffset);
                document.getElementById('serverTime').textContent = this.formatTime(serverTime);
            }

            formatTime(date) {
                return date.toLocaleTimeString('pt-BR', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
            }

            connect() {
                if (this.isConnected) {
                    this.log('J√° est√° conectado ao servidor', 'warning');
                    return;
                }

                this.isConnected = true;
                this.updateConnectionStatus();
                this.log(`Cliente ${this.clientId} conectado ao servidor`, 'success');
                
                // Simula adi√ß√£o do cliente na lista do servidor
                this.clients.push({
                    id: this.clientId,
                    offset: this.localTimeOffset
                });
                
                document.getElementById('clientCount').textContent = this.clients.length;
            }

            disconnect() {
                if (!this.isConnected) {
                    this.log('N√£o est√° conectado ao servidor', 'warning');
                    return;
                }

                this.isConnected = false;
                this.updateConnectionStatus();
                this.log(`Cliente ${this.clientId} desconectado do servidor`, 'info');
                
                // Remove cliente da lista
                this.clients = this.clients.filter(c => c.id !== this.clientId);
                document.getElementById('clientCount').textContent = this.clients.length;
            }

            updateConnectionStatus() {
                const statusEl = document.getElementById('connectionStatus');
                if (this.isConnected) {
                    statusEl.innerHTML = '<span class="status connected">Conectado</span>';
                } else {
                    statusEl.innerHTML = '<span class="status disconnected">Desconectado</span>';
                }
            }

            async syncTime() {
                if (!this.isConnected) {
                    this.log('Conecte-se ao servidor primeiro!', 'error');
                    return;
                }

                this.log('Iniciando sincroniza√ß√£o (Algoritmo de Berkeley)...', 'info');
                document.getElementById('connectionStatus').innerHTML = '<span class="status syncing">Sincronizando...</span>';

                // Fase 1: Coletar tempos de todos os clientes
                const t0 = performance.now();
                const clientTimes = this.collectClientTimes();
                
                // Simula lat√™ncia de rede
                await this.simulateNetworkDelay();

                // Fase 2: Calcular tempo m√©dio (servidor √© o coordenador)
                const avgOffset = this.calculateAverageTime(clientTimes);
                
                this.log(`Tempo m√©dio calculado: offset de ${avgOffset.toFixed(2)} ms`, 'info');

                // Fase 3: Calcular ajustes para cada cliente
                const adjustments = this.calculateAdjustments(clientTimes, avgOffset);
                
                // Fase 4: Aplicar ajustes
                await this.simulateNetworkDelay();
                this.applyAdjustment(adjustments);

                const t1 = performance.now();
                const rtt = t1 - t0;
                this.rttHistory.push(rtt);
                if (this.rttHistory.length > 10) this.rttHistory.shift();

                this.syncCount++;
                document.getElementById('syncCount').textContent = this.syncCount;
                document.getElementById('lastSync').textContent = new Date().toLocaleTimeString();
                document.getElementById('avgRTT').textContent = `${this.getAverageRTT().toFixed(2)} ms`;

                this.updateConnectionStatus();
                this.log(`Sincroniza√ß√£o conclu√≠da! RTT: ${rtt.toFixed(2)} ms`, 'success');
                
                this.updateStatistics(clientTimes, avgOffset);
            }

            collectClientTimes() {
                // Coleta o tempo de todos os clientes conectados
                const times = [];
                
                // Adiciona o tempo do servidor
                times.push({
                    id: 'server',
                    offset: this.serverTimeOffset,
                    time: Date.now() + this.serverTimeOffset
                });

                // Adiciona o tempo de todos os clientes
                this.clients.forEach(client => {
                    times.push({
                        id: client.id,
                        offset: client.offset,
                        time: Date.now() + client.offset
                    });
                });

                this.log(`Coletados ${times.length} tempos de clientes`, 'info');
                return times;
            }

            calculateAverageTime(clientTimes) {
                // Algoritmo de Berkeley: calcula a m√©dia dos tempos
                const sum = clientTimes.reduce((acc, client) => acc + client.offset, 0);
                return sum / clientTimes.length;
            }

            calculateAdjustments(clientTimes, avgOffset) {
                // Calcula o ajuste necess√°rio para cada cliente
                const adjustments = {};
                
                clientTimes.forEach(client => {
                    const adjustment = avgOffset - client.offset;
                    adjustments[client.id] = adjustment;
                    this.log(`${client.id}: ajuste de ${adjustment.toFixed(2)} ms`, 'info');
                });

                return adjustments;
            }

            applyAdjustment(adjustments) {
                // Aplica o ajuste ao cliente local
                const myAdjustment = adjustments[this.clientId] || 0;
                this.localTimeOffset += myAdjustment;
                
                // Atualiza offsets de todos os clientes
                this.clients.forEach(client => {
                    if (adjustments[client.id]) {
                        client.offset += adjustments[client.id];
                    }
                });

                const diff = this.localTimeOffset - this.serverTimeOffset;
                document.getElementById('timeDiff').textContent = `${diff.toFixed(2)} ms`;
                
                this.log(`Ajuste aplicado: ${myAdjustment.toFixed(2)} ms`, 'success');
            }

            updateStatistics(clientTimes, avgOffset) {
                // Calcula desvio padr√£o
                const variance = clientTimes.reduce((acc, client) => {
                    return acc + Math.pow(client.offset - avgOffset, 2);
                }, 0) / clientTimes.length;
                
                const stdDev = Math.sqrt(variance);
                document.getElementById('stdDev').textContent = `${stdDev.toFixed(2)} ms`;

                // Atualiza tempo m√©dio
                const avgTime = new Date(Date.now() + avgOffset);
                document.getElementById('avgTime').textContent = this.formatTime(avgTime);
            }

            addRandomDelay() {
                // Adiciona um atraso aleat√≥rio ao rel√≥gio local (-5000 a +5000 ms)
                const delay = (Math.random() - 0.5) * 10000;
                this.localTimeOffset += delay;
                this.log(`Atraso de ${delay.toFixed(2)} ms adicionado ao rel√≥gio local`, 'warning');
                
                // Atualiza o offset do cliente na lista
                const client = this.clients.find(c => c.id === this.clientId);
                if (client) {
                    client.offset = this.localTimeOffset;
                }
            }

            simulateMultipleClients(count) {
                this.log(`Simulando ${count} clientes adicionais...`, 'info');
                
                for (let i = 0; i < count; i++) {
                    const clientId = `sim_client_${i + 1}`;
                    const offset = (Math.random() - 0.5) * 10000; // -5s a +5s
                    
                    this.clients.push({
                        id: clientId,
                        offset: offset
                    });
                    
                    this.log(`Cliente ${clientId} criado com offset de ${offset.toFixed(2)} ms`, 'info');
                }
                
                document.getElementById('clientCount').textContent = this.clients.length;
                this.log('Clientes simulados adicionados. Execute a sincroniza√ß√£o!', 'success');
            }

            getAverageRTT() {
                if (this.rttHistory.length === 0) return 0;
                return this.rttHistory.reduce((a, b) => a + b, 0) / this.rttHistory.length;
            }

            async simulateNetworkDelay() {
                // Simula lat√™ncia de rede (10-50ms)
                const delay = 10 + Math.random() * 40;
                return new Promise(resolve => setTimeout(resolve, delay));
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                
                const timestamp = new Date().toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                
                entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;

                // Also mirror logs to the browser console for easier debugging
                if (type === 'error') {
                    console.error(`[${timestamp}] ${message}`);
                } else if (type === 'warning') {
                    console.warn(`[${timestamp}] ${message}`);
                } else if (type === 'success') {
                    console.log(`[${timestamp}] ${message}`);
                } else {
                    console.info(`[${timestamp}] ${message}`);
                }
            }

            clearLogs() {
                document.getElementById('logContainer').innerHTML = '';
                this.log('Logs limpos', 'info');
            }
        }

        // Inicializa o sistema
        const berkeleySync = new BerkeleySynchronization();

        
        class ClientRequests {
            constructor() {
                this.baseURL = 'http://127.0.0.1:5000';
                this.lastBookingData = null;
                this.timeOffset = 0; // üîπ NOVO: offset de tempo calculado
            }

            // ...existing code...

            async getServerTime() {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout
                    
                    const response = await fetch(`${this.baseURL}/time`, {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    const data = await response.json();
                    
                    berkeleySync.log(`‚è∞ Tempo do servidor: ${data.server_time_utc}`, 'info');
                    berkeleySync.log(`üìä Unix timestamp: ${data.server_unix_ms} ms`, 'info');
                    
                    return { success: true, data };
                    
                } catch (error) {
                    console.error('Erro ao obter tempo:', error);
                    
                    // üîπ DIAGN√ìSTICO DETALHADO
                    if (error.name === 'AbortError') {
                        berkeleySync.log('‚ùå Timeout: Servidor n√£o respondeu em 5s', 'error');
                    } else if (error.message.includes('Failed to fetch')) {
                        berkeleySync.log('‚ùå Servidor Flask n√£o est√° acess√≠vel. Verifique se est√° rodando em http://127.0.0.1:5000', 'error');
                    } else {
                        berkeleySync.log(`‚ùå Erro: ${error.message}`, 'error');
                    }
                    
                    return { success: false, error: error.message };
                }
            }

            /**
             * üîπ IMPLEMENTA SINCRONIZA√á√ÉO DE TEMPO (Algoritmo de Cristian simplificado)
             */
            async synchronizeTime() {
                try {
                    const t0 = performance.now();
                    const response = await fetch(`${this.baseURL}/time`);
                    const t1 = performance.now();
                    
                    const data = await response.json();
                    const rtt = t1 - t0; // Round-Trip Time
                    
                    const serverTime = new Date(data.server_time_utc).getTime();
                    const localTime = Date.now();
                    
                    // Ajusta pelo RTT/2 (tempo de ida)
                    this.timeOffset = serverTime - localTime + (rtt / 2);
                    
                    berkeleySync.log(`‚è∞ Tempo sincronizado! Offset: ${this.timeOffset.toFixed(2)} ms`, 'success');
                    
                    return this.timeOffset;
                } catch (error) {
                    console.error('Erro ao sincronizar tempo:', error);
                    berkeleySync.log('‚ùå Falha na sincroniza√ß√£o de tempo', 'error');
                    throw error;
                }
            }

            /**
             * üîπ RETORNA TIMESTAMP SINCRONIZADO
             */
            getSynchronizedTimestamp() {
                return new Date(Date.now() + this.timeOffset).toISOString();
            }

            /**
             * üîπ Cria agendamento COM SINCRONIZA√á√ÉO
             */
            async createBooking(telescopeId, cientistaId, startUTC, endUTC) {
                try {
                    // 1. SINCRONIZAR TEMPO
                    await this.synchronizeTime();
                    
                    const bookingData = {
                        telescope_id: telescopeId,
                        cientista_id: cientistaId,
                        start_utc: startUTC,
                        end_utc: endUTC,
                        request_timestamp_utc: this.getSynchronizedTimestamp() // üîπ USA TEMPO SINCRONIZADO
                    };

                    const response = await fetch(`${this.baseURL}/agendamentos`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Request-Id': `req-${Date.now()}`
                        },
                        body: JSON.stringify(bookingData)
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        berkeleySync.log(`‚ùå Erro ao criar agendamento: ${data.message || data.error}`, 'error');
                        return { success: false, error: data };
                    }

                    this.lastBookingData = data;
                    berkeleySync.log(`‚úÖ Agendamento criado: ID ${data.id}`, 'success');
                    
                    return { success: true, data };
                    
                } catch (error) {
                    console.error('Erro na requisi√ß√£o:', error);
                    berkeleySync.log('‚ùå Erro de rede ao criar agendamento', 'error');
                    return { success: false, error: error.message };
                }
            }
            

            /**
             * üîπ NOVO: Cancela um agendamento usando HATEOAS
             */
            async cancelBooking(bookingId = null) {
                try {
                    let cancelLink;

                    // üîπ Estrat√©gia 1: Usa link HATEOAS da √∫ltima resposta
                    if (this.lastBookingData && this.lastBookingData.links) {
                        cancelLink = this.lastBookingData.links.find(link => link.rel === 'cancel');
                        
                        if (cancelLink) {
                            berkeleySync.log('üìé Usando link HATEOAS para cancelar', 'info');
                        }
                    }

                    // üîπ Estrat√©gia 2: Se n√£o h√° link, busca os dados do agendamento
                    if (!cancelLink && bookingId) {
                        berkeleySync.log('üîç Buscando dados do agendamento...', 'info');
                        
                        const detailsResponse = await fetch(`${this.baseURL}/agendamentos/${bookingId}`);
                        const bookingDetails = await detailsResponse.json();
                        
                        if (bookingDetails.links) {
                            cancelLink = bookingDetails.links.find(link => link.rel === 'cancel');
                        }
                    }

                    // üîπ Se n√£o encontrou link de cancelamento
                    if (!cancelLink) {
                        berkeleySync.log('‚ö†Ô∏è Link de cancelamento n√£o dispon√≠vel (j√° cancelado?)', 'warning');
                        return { success: false, error: 'CANCEL_UNAVAILABLE' };
                    }

                    // üîπ Executa o cancelamento usando o link HATEOAS
                    const response = await fetch(`${this.baseURL}${cancelLink.href}`, {
                        method: cancelLink.method,
                        headers: {
                            'X-Request-Id': `req-${Date.now()}`
                        }
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        berkeleySync.log(`Erro ao cancelar: ${data.message}`, 'error');
                        return { success: false, error: data };
                    }

                    berkeleySync.log(`‚úÖ Agendamento cancelado: ${data.message}`, 'success');
                    
                    // üîπ Limpa dados do √∫ltimo agendamento
                    this.lastBookingData = null;
                    
                    return { success: true, data };
                    
                } catch (error) {
                    console.error('Erro ao cancelar:', error);
                    berkeleySync.log('Erro de rede ao cancelar agendamento', 'error');
                    return { success: false, error: error.message };
                }
            }

            /**
             * üîπ Lista agendamentos
             */
            async listBookings(telescopeId = null) {
                try {
                    let url = `${this.baseURL}/agendamentos`;
                    if (telescopeId) {
                        url += `?telescopio=${telescopeId}`;
                    }

                    const response = await fetch(url);
                    const data = await response.json();

                    console.log('üìã Agendamentos:', data);
                    return { success: true, data };
                    
                } catch (error) {
                    console.error('Erro ao listar:', error);
                    return { success: false, error: error.message };
                }
            }
        }

        // üîπ Instancia o cliente
        const client = new ClientRequests();

        // Fun√ß√µes UI -> cliente
        async function createBookingFromUI() {
            const telescope = document.getElementById('telescopeInput').value.trim() || 'hubble-acad';
            const scientistRaw = document.getElementById('scientistInput').value.trim();
            const scientist = scientistRaw ? parseInt(scientistRaw, 10) : 1;
            const start = document.getElementById('startInput').value.trim();
            const end = document.getElementById('endInput').value.trim();

            if (!start || !end) {
                berkeleySync.log('Preencha start e end em formato ISO (ex: 2025-12-01T10:00:00Z)', 'warning');
                return;
            }

            berkeleySync.log('Criando agendamento (via UI)...', 'info');
            const result = await client.createBooking(telescope, scientist, start, end);

            if (result.success) {
                berkeleySync.log(`Agendamento criado (UI): ID ${result.data.id}`, 'success');
                console.log('Agendamento criado (UI):', result.data);
                // Preenche o campo bookingId para facilidade de cancelamento
                document.getElementById('bookingIdInput').value = result.data.id;
            } else {
                berkeleySync.log(`Falha ao criar agendamento: ${JSON.stringify(result.error)}`, 'error');
                console.error('Falha criar agendamento (UI):', result.error);
            }
        }

        async function cancelBookingFromUI() {
            const bookingId = document.getElementById('bookingIdInput').value.trim();
            if (!bookingId) {
                berkeleySync.log('Informe o Booking ID para cancelar', 'warning');
                return;
            }

            berkeleySync.log(`Solicitando cancelamento do agendamento ${bookingId} (via UI)...`, 'info');
            const result = await client.cancelBooking(bookingId);

            if (result.success) {
                berkeleySync.log(`Agendamento ${bookingId} cancelado (UI)`, 'success');
                console.log('Cancel result:', result.data);
                document.getElementById('bookingIdInput').value = '';
            } else {
                berkeleySync.log(`Falha ao cancelar: ${JSON.stringify(result.error)}`, 'error');
                console.error('Falha cancelar (UI):', result.error);
            }
        }

        async function listBookingsFromUI() {
            const telescope = document.getElementById('telescopeInput').value.trim() || null;
            berkeleySync.log('Listando agendamentos (via UI)...', 'info');
            const result = await client.listBookings(telescope);
            if (result.success) {
                berkeleySync.log(`Agendamentos recebidos: ${result.data.length || JSON.stringify(result.data)}`, 'info');
                console.log('Agendamentos:', result.data);
                // Show summary in log
                if (Array.isArray(result.data)) {
                    result.data.slice(0, 10).forEach(b => berkeleySync.log(`ID:${b.id} telescope:${b.telescope_id} start:${b.start_utc}`, 'info'));
                }
            } else {
                berkeleySync.log(`Erro ao listar agendamentos: ${JSON.stringify(result.error)}`, 'error');
                console.error('Erro listar (UI):', result.error);
            }
        }

        // üîπ Fun√ß√µes auxiliares para usar no console
        window.testarSistema = async function() {
            console.log('üß™ Iniciando teste completo...\n');
            
            // 1. Obter tempo do servidor
            await client.getServerTime();
            
            // 2. Criar agendamento
            const result = await client.createBooking(
                'hubble-acad',
                1,
                '2025-12-25T10:00:00Z',
                '2025-12-25T11:00:00Z'
            );
            
            if (result.success) {
                console.log('‚úÖ Agendamento criado:', result.data.id);
                
                // 3. Aguardar 2 segundos
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // 4. Cancelar usando HATEOAS
                const cancelResult = await client.cancelBooking();
                
                if (cancelResult.success) {
                    console.log('‚úÖ Teste completo conclu√≠do!');
                }
            }
        }

        console.log('üí° Digite testarSistema() no console para testar o sistema completo');
        console.log('üí° Ou use: client.createBooking(...), client.cancelBooking(), client.listBookings()');


    </script>

</body>
</html>